#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Copyright (c) 2014 Lorenz Quack
#
# This software is provided 'as-is', without any express or implied warranty.
# In no event will the authors be held liable for any damages arising from the
# use of this software.
#
# Permission is granted to anyone to use this software for any purpose,
# including commercial applications, and to alter it and redistribute it
# freely, subject to the following restrictions:
#
#    1. The origin of this software must not be misrepresented; you must not
#       claim that you wrote the original software. If you use this software
#       in a product, an acknowledgment in the product documentation would be
#       appreciated but is not required.
#
#    2. Altered source versions must be plainly marked as such, and must not
#       be misrepresented as being the original software.
#
#    3. This notice may not be removed or altered from any source distribution.


"""Create python modules that embed and give access to resource files."""


try:
    import builtins
except ImportError:
    import __builtin__ as builtins
import sys
import importlib
import base64
import zlib
import argparse
import os
from datetime import datetime


__all__ = ["ResourceFile"]
VERSION = "1.0"

_RESOURCE_TEMPLATE = '''# generated by data2py. Do not edit!
"""Resource file (v{{version}}) generated by data2py on the {{datetime}}
This module provides access to data files that have been embedded in the module.
`keys()` returns a list of the embedded resources.
`get(resourcePath)` returns the raw content of the resource, i.e. binary mode.
`open(resourcePath, mode="r")` returns a file-like object to the resource.

WARNING: To prevent shadowing of builtin open() do not use import *

List of embedded resources:
{{resource_list}}
"""

VERSION = "{version}"
GENERATION_DATE = "{datetime}"

def get(resource_path):
    """returns the raw/binary content of the resource."""
    import base64
    import zlib
    encoded_data, stored_crc, mod_time = _embedded_data[resource_path]
    data = base64.b64decode(encoded_data)
    crc = zlib.crc32(data) & 0xffffffff
    if crc != stored_crc:
        raise RuntimeError("data is corrupted")
    return data

def open(resource_path, mode="r", encoding=None):
    """returns a file-like object to the resource."""
    import io
    data = get(resource_path)
    if mode == "r":
        if not encoding:
            import locale
            encoding = locale.getpreferredencoding(False)
        return io.StringIO(data.decode(encoding))
    elif mode == "rb":
        return io.BytesIO(data)
    else:
        raise RuntimeError('Unsupported mode "%s". Should be "r" or "rb"' %
                           mode)

def keys():
    """returns a list of all available resources in this file."""
    return list(_embedded_data.keys())


_embedded_data = {data}

__doc__ = __doc__.format(version=VERSION, datetime=GENERATION_DATE,
                         resource_list="  " + "\\n  ".join(keys()))

'''

class ResourceFile(object):
    """add resources with `add_resource()` and save the resource module
    with `save()`"""

    def __init__(self):
        self._resources = {}

    def _assert_resource_dir(self, resource_dir):
        if not resource_dir.startswith("/"):
            raise RuntimeError('resourceDir should be an absolute path'
                               ' not "%s"' % resource_dir)

    def add_resource(self, path, resource_dir="/"):
        self._assert_resource_dir(resource_dir)
        if os.path.isfile(path):
            self._add_file(path, resource_dir)
        elif os.path.isdir(path):
            self._add_directory(path, resource_dir)

    def _add_file(self, path, resource_dir):
        with builtins.open(path, "rb") as inFile:
            data = inFile.read()
            crc = zlib.crc32(data) & 0xffffffff
            encoded_data = base64.b64encode(data)
            filename = os.path.basename(path)
            resource_path = os.path.join(resource_dir, filename)
            self._resources[resource_path] = (encoded_data, crc,
                                              datetime.utcnow().isoformat())

    def _add_directory(self, path, base_resource_dir):
        for root, dirs, files in os.walk(path):
            relpath = os.path.relpath(root, path)
            resource_dir = os.path.join(base_resource_dir, relpath)
            for f in files:
                self.add_file(os.path.join(root, f), resource_dir)
            for d in dirs:
                self.add_directory(os.path.join(root, d), resource_dir)

    def keys(self):
        return list(self._resources.keys())

    def save(self, path):
        timestamp = datetime.utcnow().isoformat()
        content = _RESOURCE_TEMPLATE.format(datetime=timestamp,
                                            version=VERSION,
                                            data=self._resources)
        if not path:
            sys.stdout.write(content)
        else:
            with builtins.open(path, "w") as f:
                f.write(content)

    def _load_v1(self, module):
        self._resources = module._embedded_data

    def load(self, path):
        dirname, filename = os.path.split(path)
        sys.path.insert(0, dirname)
        print(dirname, filename)
        module = importlib.import_module(os.path.splitext(filename)[0])
        sys.path = sys.path[1:]
        if module.VERSION == "1.0":
            self._load_v1(module)
        else:
            raise RuntimeError("Unsupported resource version %s" %
                               module.VERSION)



if __name__ == '__main__':
    help_general = "Convert a data file to a python resource module"
    help_output = "path to where the resource file should be written to."
    help_path = ("path to resource that should be embedded into the"
                 " python resource file.")
    parser = argparse.ArgumentParser(description=help_general)
    parser.add_argument('--version', action='version', version=VERSION)
    parser.add_argument('-o', '--output', action='store', dest="outFile",
                        help=help_output)
    parser.add_argument('PATH', nargs="+", action='store', help=help_path)
    args = parser.parse_args()
    resource_file = ResourceFile()
    for path in args.PATH:
        resource_file.add_resource(path)
    resource_file.save(args.outFile)


